# -*- coding: utf-8 -*-
"""IE 690_Complete package_Dec 9.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1EczWtn32DES1PDFCxFXStdQ13d9DFuCs
"""

# setup the data reading. 
import pandas as pd
from pandas import read_parquet
#from google.colab import drive
#drive.mount('/content/drive')
import pandas as pd
import numpy as np
import math
from mip import Model, xsum, maximize, BINARY

data=pd.read_parquet("C:\\Mohammadhosein\\PhD Courses\\Fall Semester 2022\\RL and System Constrol\\For the project\\RL in ride sourcing\\Matching\\yellow_tripdata_2022-01.parquet")

#@title Default title text
class customers_data:
  def __init__(self,picTime,drpTime,passengers,tripDistance,\
               picLocation,drpLocation,fee,real_picTime,id):
    self.picTime = picTime
    self.drpTime = drpTime
    self.passengers = passengers
    self.tripDistance = tripDistance
    self.picLocation = picLocation
    self.drpLocation = drpLocation
    self.travel_time = drpTime - picTime
    self.fee = fee
    self.real_picTime = real_picTime
    self.id = id

class driver_data:
  def __init__(self,ID,status,location,remain_time):
    self.ID = ID
    self.status = status
    self.location = location
    self.remain_time = remain_time

#data = read_parquet('/content/drive/MyDrive/yellow_tripdata_2022-01.parquet')
#print(data)

# most frequent position 
#data = read_parquet('/content/drive/MyDrive/yellow_tripdata_2022-01.parquet')
position_stat = {}
for i in range(10000):
  cur_pos = data['PULocationID'][i]
  position_stat[cur_pos] = position_stat.get(cur_pos,0) + 1

Most_Frequent_20 = (sorted(position_stat.items(), key = lambda kv:(kv[1], kv[0]),reverse = True)) 
Most_Frequent_20 = Most_Frequent_20[:20]
print(Most_Frequent_20)
final_most_frequent_20 = []
for i in Most_Frequent_20:
  final_most_frequent_20.append(i[0])
print(final_most_frequent_20)

def initialize_drivers(driver_num,pos):
  drivers_map = {}
  drivers_stack_idle = []
  cnt = 0
  for j in pos:
    for _ in range(driver_num):
      cur_driver = driver_data(cnt,'idle',j,0)
      drivers_map[cnt] = cur_driver
      drivers_stack_idle.append(cur_driver)
      cnt += 1
  return drivers_map,drivers_stack_idle

drivers_map,drivers_stack_idle = initialize_drivers(5,final_most_frequent_20)
print(drivers_map)
#print(drivers_stack_idle)

#@title Default title text
import collections
#data = read_parquet('/content/drive/MyDrive/yellow_tripdata_2022-01.parquet')
day_map = collections.defaultdict(list)
#print(data)
dates = ['01']

for i in range(len(data)):
    cur_day = str(data['tpep_pickup_datetime'][i])[8:10]
    #print(data['DOLocationID'][i])
    #print(cur_day)
    if not cur_day in dates: continue
    real_picTime = str(data['tpep_pickup_datetime'][i])
    temp = str(data['tpep_pickup_datetime'][i]).split(' ')
    temp = temp[1].split(':')
    picHour, picMin = int(temp[0]), int(temp[1])
    picTime = picHour * 60 + picMin
    if picTime < 360 or picTime > 780: continue
    
    temp = str(data['tpep_dropoff_datetime'][i]).split(' ')
    temp = temp[1].split(':')
    drpHour, drpMin = int(temp[0]), int(temp[1])
    drpTime = drpHour * 60 + drpMin

    passengers = str(data['passenger_count'][i])
    tripDistance = str(data['trip_distance'][i])
    picLocation = str(data['PULocationID'][i])
    drpLocation = str(data['DOLocationID'][i])
    fee = float(data['total_amount'][i])
    cur_data = customers_data(picTime, drpTime, passengers,\
                              tripDistance, picLocation,drpLocation,fee,real_picTime,i)

    day_map[cur_day].append(cur_data)

print(len(day_map['01']))

print(timeLine)
print(single_day_time_map[5][0].picLocation)
print(single_day_time_map[5][1].picLocation)



import bisect
single_day_time_map = collections.defaultdict(list)
for key in day_map:
  for i in range(len(day_map[key])):
    cur_time = day_map[key][i].picTime
    cur_location = day_map[key][i].picLocation
    single_day_time_map[cur_time].append(day_map[key][i])

timeLine = sorted(single_day_time_map.keys())
new_time_map = {}
combine_time_line = []
for i in range(0,60 * 24, 10):
  new_time_map[i] = []
  combine_time_line.append(i)
#print(new_time_map)
for time in timeLine:
  indx = bisect.bisect_right(combine_time_line,time)
  for data in single_day_time_map[time]:
    new_time_map[combine_time_line[indx - 1]].append(data)

for key in new_time_map:
  print("%d:" %(key))
  for i in new_time_map[key]:
    print(i.picTime)
  print("=================")
#for i in range(len(single_day_time_map[25])):
#  print(single_day_time_map[25][i].drpLocation)

#print(timeLine)

#loading data
state_values=pd.read_csv('C:\Mohammadhosein\PhD Courses\Fall Semester 2022\RL and System Constrol\Exports\statevaluse.csv',header=None)
state_values=state_values.values
state_values=np.reshape(state_values,(265,42))

ODTT=pd.read_csv('C:\Mohammadhosein\PhD Courses\Fall Semester 2022\RL and System Constrol\Exports\ODTTime.csv',header=None)
ODTT=ODTT.values
ODTT=np.reshape(ODTT,(265,265))

"""# Action values"""

def action_value_function(state_value,ODTT,passn_list,driver_list,  gamma,currenttime):
    trip_requests=len(passn_list)
    available_driver=len(driver_list)
    action_value=np.zeros((available_driver,trip_requests))
    pass_driv_assg=np.zeros((available_driver,trip_requests))
    for i in range (0,available_driver):
        for j in range (0, trip_requests):
            action_value[i][j]= (gamma**(ODTT[driver_list[i][1]-1, passn_list[j][1]-1] +passn_list[j][4]))*state_value[ passn_list[j][2]-1 ][currenttime]-state_value[ driver_list[i][1]-1 ][currenttime]+passn_list[j][3]
            pass_driv_assg[i][j]=passn_list[j][0]
    action_value=action_value.T
    return action_value,pass_driv_assg

def fare_base_function(passn_list,driver_list):
    trip_requests=len(passn_list)
    available_driver=len(driver_list)
    action_value=np.zeros((available_driver,trip_requests))
    pass_driv_assg=np.zeros((available_driver,trip_requests))
    for i in range (0,available_driver):
        for j in range (0, trip_requests):
            action_value[i][j]= passn_list[j][3]
            pass_driv_assg[i][j]=passn_list[j][0]
    action_value=action_value.T
    return action_value,pass_driv_assg

"""# Matching"""

def matching(action_value,pass_driv_assg,trip_requests_list,available_driver_list):
    available_driver=len(available_driver_list)
    trip_requests=len(trip_requests_list)
    print (available_driver,trip_requests)
    model=Model()
    # trip * driver
    x=[[model.add_var(var_type=BINARY) for j in range (0,available_driver)] for i in range (0,trip_requests)]
    model.objective = maximize(xsum(action_value[i][j]*x[i][j] for i in range (0,trip_requests) for j  in range (0,available_driver)))
    # Each passenger receiev at most one matched driver
    for i in range (0,trip_requests):
        model += xsum(x[i][j] for j in range (0,available_driver) ) <= 1
    for j in range (0,available_driver):
        model += xsum(x[i][j] for i in range (0,trip_requests) ) <= 1
    solution=np.zeros((trip_requests,available_driver))
    model.optimize()
    for i in range (0,trip_requests):
        solution[i]= ([x[i][j].x for j in range (0,available_driver)])
    total_reward=np.sum(solution*action_value)
    pass_driv_assg=np.sum(solution*pass_driv_assg.T,axis=0)
    driver_assignment=pass_driv_assg=pass_driv_assg+(pass_driv_assg==0)*-1
    driver_assignment=np.reshape(driver_assignment,(len(driver_assignment),1 ) )
    drv_id=np.reshape(available_driver_list,( len(available_driver_list) ,2  ))
    drv_id=drv_id.T[0]
    drv_id=np.reshape(drv_id,(len(drv_id),1 ))
    driver_assignment=np.concatenate((drv_id,driver_assignment),axis=1)
    serverd_pass=np.sum(solution,axis=1)
    serverd_pass=np.reshape(serverd_pass, (len (serverd_pass),1))
    gained_revenue=np.dot(serverd_pass.T,np.reshape(trip_requests_list,(len(trip_requests_list),np.shape(trip_requests_list)[1] )).T[3])[0]
    n_servertrips=np.sum(serverd_pass)
    n_unserved=len(serverd_pass)-n_servertrips
    passn_id=np.reshape(trip_requests_list,(len(trip_requests_list),np.shape(trip_requests_list)[1] )).T[0]
    passn_id=np.reshape(passn_id,(len(passn_id),1 ))
    serverd_pass=np.concatenate((passn_id,serverd_pass),axis=1)
    n_vacant=len(driver_assignment)-n_servertrips
    # Outputs: matching of passengers, (2) matching of drivers, (3) number of serived tripes, (4) numbe of unserved trips, (5) number of vacant cars, (6) gained reward, (7) gained revenue
    return serverd_pass,driver_assignment, n_servertrips,n_unserved,n_vacant ,total_reward,gained_revenue

print(new_time_map.keys())

len(drivers_stack_idle)

drivers_map,drivers_stack_idle = initialize_drivers(30,final_most_frequent_20)
waiting_customers = []
available_drivers = []
serving_drivers = []
customer_dictionary = {}
driver_dictionary = {}
all_out_puts=[]
for driver in drivers_stack_idle:
  available_drivers.append([driver.ID,driver.location])
  driver_dictionary[driver.ID] = [driver.ID,driver.location]

#print(available_drivers)
for key in new_time_map:
    flag = 1
    '''
    print("waiting_customers",end = "")
    print(waiting_customers)
    print("available_drivers",end = "")
    print(available_drivers)
    print("serving_drivers",end = "")
    print(serving_drivers)
    print("customer_dictionary",end = "")
    print(customer_dictionary)
    print("driver_dictionary",end = "")
    print(driver_dictionary)
    print("==========================================")
    '''
    
    cur_round_time_stamp = int(int(key) / 10 - 36)
    print("TimeStamp:", end = "")
    print(cur_round_time_stamp)
    if cur_round_time_stamp < 0 or cur_round_time_stamp > 3: continue
    for customer in new_time_map[key]:
      waiting_customers.append([customer.id,int(customer.picLocation),int(customer.drpLocation),customer.fee,math.ceil(customer.travel_time/10) ])
      customer_dictionary[customer.id] = [customer.id,int(customer.picLocation),int(customer.drpLocation),customer.fee,math.ceil(customer.travel_time/10)  ]
    if len(waiting_customers)*len(available_drivers)!=0:
        action_value,pass_driv_assg=action_value_function(state_values,ODTT,waiting_customers,available_drivers,0.9,cur_round_time_stamp)
        #action_value,pass_driv_assg=fare_base_function(waiting_customers,available_drivers)
        match_data=matching(action_value,pass_driv_assg,waiting_customers,available_drivers)
        print ('Gained revenue: ', match_data[-1])
        print ("No. Costumers:", len(waiting_customers), "No. Drivers: ",len(available_drivers)  )
        all_out_puts=all_out_puts+[np.reshape(match_data[2:],(1,5))]
    else:
        flag = 0
        print ("No. Costumers:", len(waiting_customers), "No. Drivers: ",len(available_drivers)  )
        all_out_puts=all_out_puts+[match_data[2],len(waiting_customers) ,len(available_drivers) ,match_data[5] ,match_data[6]]
    
    

    for driver in serving_drivers:
        driver.remain_time -= 1
        if driver.remain_time <= 0:
            available_drivers.append([driver.ID,driver.location])
            serving_drivers.remove(driver)
    
    if not flag: continue
    for i in match_data[0]:
        if i[1]:
            index = customer_dictionary[i[0]]
            waiting_customers.remove(index)

    for i in match_data[1]:
        if i[1] != -1:
            index = driver_dictionary[i[0]]
            available_drivers.remove(index)
            driver_location = index[1]
            pic_location = customer_dictionary[i[1]][1]
            drp_location = customer_dictionary[i[1]][2]
            travel_time = customer_dictionary[i[1]][-1]
            remain_time = ODTT[driver_location-1, pic_location-1] + int(travel_time)
            cur_driver = driver_data(index[0],'serving',customer_dictionary[i[1]][2],remain_time)
            serving_drivers.append(cur_driver)
            driver_dictionary[index[0]] = [index[0],customer_dictionary[i[1]][2]]

all_out_puts=pd.DataFrame(np.reshape(all_out_puts,( len(all_out_puts)  ,5)),columns=['Served_Costumers','Waiting_Costumers','Idle_AVs','Gained_reward','Gained_revenue'])
all_out_puts.to_csv('C:\\Mohammadhosein\\PhD Courses\\Fall Semester 2022\\RL and System Constrol\\For the project\\Exports\\RL_30D')

driver_dictionary[1]

